type Balancer @entity(immutable: true) {
    id: Bytes!
    pools: [Pool!] @derivedFrom(field: "vault")
    globalMetrics: GlobalVaultMetric!
}

type GlobalVaultMetric @entity {
    id: Bytes!
    vault: Balancer!
    startTime: Int!
    totalSwapVolume: BigDecimal!
    totalSwapFee: BigDecimal!
    totalSwapCount: BigInt!
    totalLiquidity: BigDecimal!
}


type Pool @entity(immutable: true) {
    id: Bytes!
    address: Bytes!
    vault: Balancer!
    name: String!
    owner: Bytes
    poolType: String!
    createTime: BigInt!
    swapConfig: SwapConfig!
    globalMetrics: GlobalPoolMetric!
    dailyMetrics: [DailyPoolMetric!] @derivedFrom(field: "pool")
    tokensList: [Bytes!]!
    tokens: [PoolToken!]! @derivedFrom(field: "pool") # underlying tokens
    tokenWeights: [TokenWeight!]! @derivedFrom(field: "pool")
    weightUpdates: [GradualWeightUpdate!]! @derivedFrom(field: "pool")
    userShares: [PoolShares!]! @derivedFrom(field: "pool")
    customPoolData: CustomPoolData
}

type PoolAddressToId @entity(immutable: true) {
    id: Bytes!
    poolId: Bytes!
}


interface CustomPoolData {
    id: Bytes!
    pool: Pool!
    poolId: Bytes!
}

type SwapConfig @entity {
    id: Bytes!
    fee: BigDecimal!
    gradualFeeUpdate: GradualSwapFeeUpdate
    swapEnabled: Boolean!
}

type GradualSwapFeeUpdate @entity {
    id: Bytes!
    scheduledTimestamp: Int!
    startTimestamp: Int!
    endTimestamp: Int!
    startFee: BigDecimal!
    endFee: BigDecimal!
}

#type WeightedPoolData implements CustomPoolData @entity(immutable: true) {
#    id: Bytes!
#    pool: Pool!
#    poolId: Bytes!
#}

type StablePoolData implements CustomPoolData @entity(immutable: true) {
    id: Bytes!
    pool: Pool!
    poolId: Bytes!
    amp: Amp!
}

type LinearPoolData implements CustomPoolData @entity(immutable: true) {
    id: Bytes!
    pool: Pool!
    poolId: Bytes!
    lowerTarget: BigDecimal!
    upperTarget: BigDecimal!
}

type LiquidityBootstrappingPoolData implements CustomPoolData @entity(immutable: true) {
    id: Bytes!
    pool: Pool!
    poolId: Bytes!
}

type TokenWeight @entity {
    id: Bytes!
    pool: Pool!
    poolId: Bytes!
    token: Token!
    tokenAddress: Bytes!
    weight: BigDecimal!
}

type GlobalPoolMetric @entity {
    id: Bytes!
    pool: Pool!
    poolId: Bytes!
    startTime: Int!
    totalSwapVolume: BigDecimal!
    totalSwapFee: BigDecimal!
    totalLiquidity: BigDecimal!
    totalShares: BigDecimal!
#    swaps: [Swap!] @derivedFrom(field: "poolMetric")
    totalTransactions: BigInt!
    swapsCount: BigInt!
    holdersCount: BigInt!
}

type DailyPoolMetric @entity {
    id: Bytes!
    pool: Pool!
    poolId: Bytes!
    startTime: Int!
    totalSwapVolume: BigDecimal!
    totalSwapFee: BigDecimal!
    addedLiquidity: BigDecimal!
    removedLiquidity: BigDecimal!
    totalShares: BigDecimal!
    totalTransactions: BigInt!
#    swaps: [Swap!] @derivedFrom(field: "poolMetric")
    swapsCount: BigInt!
#    holdersCount: BigInt!
}

type Amp @entity {
    id: Bytes!
    value: BigInt!
    gradualUpdate: GradualAmpUpdate
}

type GradualAmpUpdate @entity {
    id: Bytes!
    poolData: StablePoolData!
    scheduledTimestamp: Int!
    startTimestamp: Int!
    endTimestamp: Int!
    startAmp: BigInt!
    endAmp: BigInt!
}

type GradualWeightUpdate @entity {
    id: Bytes!
    pool: Pool!
    poolId: Bytes!
    scheduledTimestamp: Int!
    startTimestamp: Int!
    endTimestamp: Int!
    startWeights: [BigInt!]!
    endWeights: [BigInt!]!
}

type Token @entity(immutable: true) {
    id: Bytes!
    address: Bytes!
    name: String!
    decimals: Int!
    symbol: String!
    tokenPrice: TokenPrice @derivedFrom(field: "token")
}

type PoolShares @entity {
    id: Bytes!
    pool: Pool!
    poolId: Bytes!
    user: User!
    userAddress: Bytes!
    token: Token!
    tokenAddress: Bytes!
    balance: BigDecimal!
    pricePerShare: BigDecimal!
}

type PoolToken @entity {
    id: Bytes!
    pool: Pool!
    poolId: Bytes!
    token: Token!
    tokenAddress: Bytes!
    balance: BigDecimal!
    priceUsd: BigDecimal!
    swapCount: BigInt!
}


type User @entity(immutable: true) {
    id: Bytes!
    address: Bytes!
    sharesOwned: [PoolShares!] @derivedFrom(field: "user")
#    swaps: [Swap!] @derivedFrom(field: "userAddress")
    userInternalBalances: [UserInternalBalance!] @derivedFrom(field: "user")
}

type UserInternalBalance @entity {
    id: Bytes!
    user: User!
    userAddress: Bytes!
    token: Token!
    tokenAddress: Bytes!
    balance: BigDecimal!
}

type TokenPrice @entity {
    id: Bytes! # address of token + address of pricing asset
    token: Token!
    tokenAddress: Bytes!
    amount: BigDecimal!
    pricingAsset: Bytes! # address of stable asset
    price: BigDecimal!
    block: BigInt!
    timestamp: Int!
    priceUSD: BigDecimal!
}

#type Swap @entity(immutable: true) {
#    id: ID!
#    caller: Bytes!
#    tokenIn: Bytes!
#    tokenInSym: String!
#    tokenOut: Bytes!
#    tokenOutSym: String!
#    tokenAmountIn: BigDecimal!
#    tokenAmountOut: BigDecimal!
#    poolId: Pool!
#    userAddress: User!
#    timestamp: Int!
#    tx: Bytes!
#    valueUSD: BigDecimal!
#}
