type Balancer @entity(immutable: true) {
    id: Bytes!
    pools: [Pool!] @derivedFrom(field: "vault")
#    vaultMetrics: [PoolMetric!]!
}

type Pool @entity(immutable: true) {
    id: Bytes!
    poolId: Bytes!
    address: Bytes!
    vault: Balancer!
    name: String!
    owner: Bytes
    createTime: BigInt!
#    poolMetrics: [PoolMetric!]! @derivedFrom(field: "pool")
    config: PoolConfig!
    tokensList: [Bytes!]!
    tokens: [PoolTokenBalance!]! @derivedFrom(field: "pool") # underlying tokens
    totalShares: PoolSharesBalance @derivedFrom(field: "pool") #bpt token
    userShares: UserTokenBalance @derivedFrom(field: "pool")
    customPoolData: CustomPoolData! @derivedFrom(field: "pool")
}

type PoolConfig @entity {
    id: Bytes!
    swapFee: BigDecimal!
    swapEnabled: Boolean!
}

interface CustomPoolData {
    id: Bytes!
    pool: Pool!
    swapFee: BigDecimal!
}

type WeightedPoolData implements CustomPoolData @entity(immutable: true) {
    id: Bytes!
    pool: WeightedPoolData!
    tokenWeights: [TokenWeight!]! @derivedFrom(field: "poolData")
}

type StablePoolData implements CustomPoolData @entity(immutable: true) {
    id: Bytes!
    pool: StablePoolData!
    amp: BigInt
    ampUpdates: [AmpUpdate!]! @derivedFrom(field: "poolData")
}

type LinearPoolData implements CustomPoolData @entity(immutable: true) {
    id: Bytes!
    pool: LinearPoolData
    lowerTarget: BigDecimal!
    upperTarget: BigDecimal!
}

type LiquidityBootstrappingPoolData implements CustomPoolData @entity(immutable: true) {
    id: Bytes!
    pool: LiquidityBootstrappingPoolData!
    tokenWeights: [TokenWeight!]! @derivedFrom(field: "poolData")
    weightUpdates: [GradualWeightUpdate!] @derivedFrom(field: "poolData")
}

type TokenWeight @entity {
    id: Bytes!
    poolData: CustomPoolData!
    token: Token!
    tokenAddress: Bytes!
    weight: BigDecimal
}

#interface PoolMetric {
#    id: Bytes!
#    pool: Pool!
#    startTime: Int!
#    totalSwapVolume: BigDecimal!
#    totalSwapFee: BigDecimal!
#    totalLiquidity: BigDecimal!
#    totalShares: BigDecimal!
#    swaps: [Swap!] @derivedFrom(field: "poolMetric")
#    swapsCount: BigInt!
#    holdersCount: BigInt!
#    block: BigInt!
#    timestamp: BigInt!
#}
#
#type GlobalPoolMetric implements PoolMetric @entity {
#    id: Bytes!
#    pool: Pool!
#    startTime: Int!
#    totalSwapVolume: BigDecimal!
#    totalSwapFee: BigDecimal!
#    totalLiquidity: BigDecimal!
#    totalShares: BigDecimal!
#    swaps: [Swap!] @derivedFrom(field: "poolMetric")
#    swapsCount: BigInt!
#    holdersCount: BigInt!
#    block: BigInt!
#    timestamp: BigInt!
#}
#
#type DailyPoolMetric implements PoolMetric @entity {
#    id: Bytes!
#    pool: Pool!
#    startTime: Int!
#    totalSwapVolume: BigDecimal!
#    totalSwapFee: BigDecimal!
#    totalLiquidity: BigDecimal!
#    addedLiquidity: BigDecimal!
#    removedLiquidity: BigDecimal!
#    totalShares: BigDecimal!
#    swaps: [Swap!] @derivedFrom(field: "poolMetric")
#    swapsCount: BigInt!
#    holdersCount: BigInt!
#    block: BigInt!
#    timestamp: BigInt!
#}

type AmpUpdate @entity(immutable: true) {
    id: Bytes!
    poolData: StablePoolData!
    scheduledTimestamp: Int!
    startTimestamp: Int!
    endTimestamp: Int!
    startAmp: BigInt!
    endAmp: BigInt!
}

type GradualWeightUpdate @entity(immutable: true) {
    id: Bytes!
    poolData: LiquidityBootstrappingPoolData!
    scheduledTimestamp: Int!
    startTimestamp: Int!
    endTimestamp: Int!
    startWeights: [BigInt!]!
    endWeights: [BigInt!]!
}

type Token @entity(immutable: true) {
    id: Bytes!
    address: Bytes!
    name: String!
    decimals: Int!
    symbol: String!
}

interface TokenBalance {
    id: Bytes!
    token: Token!
    balance: BigDecimal!
    block: BigInt!
    timestamp: BigInt!
}

type PoolSharesBalance implements TokenBalance @entity {
    id: Bytes!
    pool: Pool!
    poolId: Bytes!
    token: Token!
    tokenAddress: Bytes!
    balance: BigDecimal!
    block: BigInt!
    timestamp: BigInt!
}

type PoolTokenBalance implements TokenBalance @entity {
    id: Bytes!
    pool: Pool!
    poolId: Bytes!
    token: Token!
    tokenAddress: Bytes!
    balance: BigDecimal!
    block: BigInt!
    timestamp: BigInt!
}

type UserTokenBalance implements TokenBalance @entity {
    id: Bytes!
    pool: Pool!
    poolId: Bytes!
    token: Token!
    tokenAddress: Bytes!
    user: User!
    userAddress: Bytes!
    balance: BigDecimal!
    block: BigInt!
    timestamp: BigInt!
}


type User @entity(immutable: true) {
    id: Bytes!
    address: Bytes!
    sharesOwned: [UserTokenBalance!] @derivedFrom(field: "user")
#    swaps: [Swap!] @derivedFrom(field: "userAddress")
    userInternalBalances: [UserTokenBalance!] @derivedFrom(field: "user")
}
#type Swap @entity(immutable: true) {
#    id: ID!
#    caller: Bytes!
#    tokenIn: Bytes!
#    tokenInSym: String!
#    tokenOut: Bytes!
#    tokenOutSym: String!
#    tokenAmountIn: BigDecimal!
#    tokenAmountOut: BigDecimal!
#    poolId: Pool!
#    userAddress: User!
#    timestamp: Int!
#    tx: Bytes!
#    valueUSD: BigDecimal!
#}
