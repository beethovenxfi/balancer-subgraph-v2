type Balancer @entity(immutable: true) {
    id: Bytes!
    pools: [Pool!] @derivedFrom(field: "vault")
    globalMetrics: GlobalVaultMetric!
    tokens: [VaultToken!]! @derivedFrom(field: "vault")
}

type GlobalVaultMetric @entity {
    id: Bytes!
    vault: Balancer!
    startTime: Int!
    totalSwapVolume: BigDecimal!
    totalSwapFee: BigDecimal!
    swapCount: BigInt!
    totalLiquidity: BigDecimal!
}

type DailyVaultMetric @entity {
    id: Bytes!
    vault: Balancer!
    startTime: Int!
    totalSwapVolume: BigDecimal!
    totalSwapFee: BigDecimal!
    addedLiquidity: BigDecimal!
    removedLiquidity: BigDecimal!
    swapCount: BigInt!
    totalTransactions: BigInt!
}


type Pool @entity(immutable: true) {
    id: Bytes!
    address: Bytes!
    vault: Balancer!
    name: String!
    owner: Bytes
    poolType: String!
    phantomPool: Boolean!
    createTime: BigInt!
    shareToken: Token!
    swapConfig: SwapConfig!
    globalMetrics: GlobalPoolMetric!
    dailyMetrics: [DailyPoolMetric!] @derivedFrom(field: "pool")
    tokenAddresses: [Bytes!]!
    tokens: [PoolToken!]! @derivedFrom(field: "pool") # underlying tokens

    tokenWeights: [TokenWeight!]! @derivedFrom(field: "pool")
    weightUpdates: [GradualWeightUpdate!]! @derivedFrom(field: "pool")

    userShares: [PoolShares!]! @derivedFrom(field: "pool")
    customPoolData: CustomPoolData

    investments: [PoolInvestmentAction!]! @derivedFrom(field: "pool")
    swaps: [Swap!]! @derivedFrom(field: "pool")
    interactions: [PoolInteraction!]! @derivedFrom(field: "pool")
}

type PoolAddressToId @entity(immutable: true) {
    id: Bytes!
    poolId: Bytes!
}


interface CustomPoolData {
    id: String!
    pool: Pool!
    poolId: Bytes!
}

type SwapConfig @entity {
    id: Bytes!
    fee: BigDecimal!
    managementFee: BigDecimal!
    gradualFeeUpdate: GradualSwapFeeUpdate
    swapEnabled: Boolean!
}

type GradualSwapFeeUpdate @entity {
    id: Bytes!
    scheduledTimestamp: Int!
    startTimestamp: Int!
    endTimestamp: Int!
    startFee: BigDecimal!
    endFee: BigDecimal!
}

#type WeightedPoolData implements CustomPoolData @entity(immutable: true) {
#    id: Bytes!
#    pool: Pool!
#    poolId: Bytes!
#}

type StablePoolData implements CustomPoolData @entity(immutable: true) {
    id: String!
    pool: Pool!
    poolId: Bytes!
    amp: Amp!
}

type LinearPoolData implements CustomPoolData @entity(immutable: true) {
    id: String!
    pool: Pool!
    poolId: Bytes!
    mainIndex: Int!
    wrappedIndex: Int!
    targets: LinearPoolTarget!
    priceRateProviders: [PriceRateProvider!] @derivedFrom(field: "poolData")
}

type LinearPoolTarget @entity {
    id: Bytes!
    lowerTarget: BigDecimal!
    upperTarget: BigDecimal!
}

type TokenWeight @entity {
    id: Bytes!
    pool: Pool!
    poolId: Bytes!
    token: Token!
    tokenAddress: Bytes!
    weight: BigDecimal!
}

type GlobalPoolMetric @entity {
    id: Bytes!
    pool: Pool!
    poolId: Bytes!
    startTime: Int!
    totalSwapVolume: BigDecimal!
    totalSwapFee: BigDecimal!
    totalLiquidity: BigDecimal!
    totalShares: BigDecimal!
#    swaps: [Swap!] @derivedFrom(field: "poolMetric")
    totalTransactions: BigInt!
    swapsCount: BigInt!
    holdersCount: BigInt!
}

type DailyPoolMetric @entity {
    id: Bytes!
    pool: Pool!
    poolId: Bytes!
    startTime: Int!
    totalSwapVolume: BigDecimal!
    totalSwapFee: BigDecimal!
    addedLiquidity: BigDecimal!
    removedLiquidity: BigDecimal!
    totalTransactions: BigInt!
    swapCount: BigInt!
}

type Amp @entity {
    id: Bytes!
    value: BigInt!
    gradualUpdate: GradualAmpUpdate
}

type GradualAmpUpdate @entity {
    id: Bytes!
    poolData: StablePoolData!
    scheduledTimestamp: Int!
    startTimestamp: Int!
    endTimestamp: Int!
    startAmp: BigInt!
    endAmp: BigInt!
}

type GradualWeightUpdate @entity {
    id: Bytes!
    pool: Pool!
    poolId: Bytes!
    scheduledTimestamp: Int!
    startTimestamp: Int!
    endTimestamp: Int!
    startWeights: [BigInt!]!
    endWeights: [BigInt!]!
}

type Token @entity(immutable: true) {
    id: Bytes!
    address: Bytes!
    name: String!
    decimals: Int!
    symbol: String!
    bpToken: Boolean!
    tokenPrice: [TokenPrice!]! @derivedFrom(field: "token")
}

type PoolShares @entity {
    id: Bytes!
    pool: Pool!
    poolId: Bytes!
    user: User!
    userAddress: Bytes!
    token: Token!
    tokenAddress: Bytes!
    balance: BigDecimal!
    pricePerShare: BigDecimal!
}

type VaultToken @entity {
    id: Bytes!
    vault: Balancer!
    token: Token!
    tokenAddress: Bytes!
    balance: BigDecimal!
    swapCount: BigInt!
}

type PoolToken @entity {
    id: Bytes!
    pool: Pool!
    poolId: Bytes!
    token: Token!
    tokenAddress: Bytes!
    balance: BigDecimal!
    swapCount: BigInt!
}


type User @entity(immutable: true) {
    id: Bytes!
    address: Bytes!
    sharesOwned: [PoolShares!] @derivedFrom(field: "user")
#    swaps: [Swap!] @derivedFrom(field: "userAddress")
    userInternalBalances: [UserInternalBalance!] @derivedFrom(field: "user")
}

type UserInternalBalance @entity {
    id: Bytes!
    user: User!
    userAddress: Bytes!
    token: Token!
    tokenAddress: Bytes!
    balance: BigDecimal!
}

type TokenPrice @entity {
    id: Bytes! # address of token + address of pricing asset
    token: Token!
    tokenAddress: Bytes!
    amount: BigDecimal!
    pricingAsset: Bytes! # address of stable asset
    price: BigDecimal!
    block: BigInt!
    timestamp: Int!
    priceUSD: BigDecimal!
}

type PriceRateProvider @entity {
    id: Bytes!
    token: Token!
    tokenAddress: Bytes!
    poolData: LinearPoolData!
    address: Bytes!
    rate: BigDecimal!
    lastCached: Int!
    cacheDuration: Int!
    cacheExpiry: Int!
}

interface PoolInteraction {
    id: ID!
    pool: Pool!
    poolId: Bytes!
    timestamp: Int!
    sender: Bytes!
    user: User!
    userAddress: Bytes!
    valueUSD: BigDecimal!
    tx: Bytes!
}

interface PoolInvestmentAction {
    id: ID!
    sender: Bytes!
    pool: Pool!
    poolId: Bytes!
    tokenAddresses: [Bytes!]!
    amounts: [BigDecimal!]!
    user: User!
    userAddress: Bytes!
    timestamp: Int!
    valueUSD: BigDecimal!
    tx: Bytes!
}

type PoolJoin implements PoolInteraction & PoolInvestmentAction  @entity(immutable: true) {
    id: ID!
    sender: Bytes!
    pool: Pool!
    poolId: Bytes!
    tokenAddresses: [Bytes!]!
    amounts: [BigDecimal!]!
    user: User!
    userAddress: Bytes!
    timestamp: Int!
    valueUSD: BigDecimal!
    tx: Bytes!
}


type PoolExit implements PoolInteraction & PoolInvestmentAction  @entity(immutable: true) {
    id: ID!
    sender: Bytes!
    pool: Pool!
    poolId: Bytes!
    tokenAddresses: [Bytes!]!
    amounts: [BigDecimal!]!
    user: User!
    userAddress: Bytes!
    timestamp: Int!
    valueUSD: BigDecimal!
    tx: Bytes!
}

type Swap implements PoolInteraction  @entity(immutable: true) {
    id: ID!
    sender: Bytes!
    pool: Pool!
    poolId: Bytes!
    tokenIn: Token!
    tokenInAddress: Bytes!
    tokenOut: Token!
    tokenOutAddress: Bytes!
    amountIn: BigDecimal!
    amountOut: BigDecimal!
    user: User!
    userAddress: Bytes!
    valueUSD: BigDecimal!
    timestamp: Int!
    tx: Bytes!
}


#type Swap @entity(immutable: true) {
#    id: ID!
#    caller: Bytes!
#    tokenIn: Bytes!
#    tokenInSym: String!
#    tokenOut: Bytes!
#    tokenOutSym: String!
#    tokenAmountIn: BigDecimal!
#    tokenAmountOut: BigDecimal!
#    poolId: Pool!
#    userAddress: User!
#    timestamp: Int!
#    tx: Bytes!
#    valueUSD: BigDecimal!
#}
